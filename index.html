<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WZ Stats Viewer — structures & weapons</title>
<link rel="icon" href="favicon.ico" />
<style>
:root{ --bg:#0f1720; --panel:#151e28; --fg:#e6eef7; --muted:#93a6bb; --accent:#4da3ff; --border:#263445; --ok:#2ecc71; --warn:#f1c40f; --bad:#e74c3c; }
*{ box-sizing: border-box; }
html,body{ margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
header{ position:sticky; top:0; background:var(--panel); border-bottom:1px solid var(--border); padding:10px 12px; z-index:10; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
h1{ margin:0; font-size:18px; font-weight:600; letter-spacing:.2px; }
.badge{ font-size:12px; padding:4px 8px; background:#1f2a36; border:1px solid var(--border); color:#93a6bb; border-radius:999px; }
.container{ padding:16px; width: 100%; margin: 0 auto; }
.toolbar{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
input[type="text"]{ background:#0e141c; color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:10px 12px; width:260px; }
button,.btn{ background:var(--accent); border:none; color:#021423; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; }
button.secondary{ background:#1f2a36; color:var(--fg); border:1px solid var(--border); }
.secondary.active{ background:var(--accent); color:#04111e; border-color:transparent; }
button.filter-chip{ background:#1f2a36; color:var(--fg); border:1px solid var(--border); }
button.filter-chip.active{ background:var(--accent); color:#04111e; border-color:transparent; }
button:disabled{ opacity:.5; cursor:not-allowed; }
.tabbar{ display:flex; gap:8px; margin:12px 0; }
.tab{ padding:8px 12px; border-radius:999px; border:1px solid var(--border); cursor:pointer; }
.tab.active{ background:var(--accent); color:#04111e; border-color:transparent; }
.panel{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px; }
.small{ font-size:12px; color:var(--muted); }
table{ width:100%; border-collapse:collapse; table-layout:auto; }
th, td{ padding:8px 10px; border-bottom:1px solid var(--border); white-space:nowrap; overflow:visible; text-overflow:clip; text-align:left !important; }
th{ position:sticky; top:0; background:var(--panel); cursor:pointer; user-select:none; text-align:left !important; }
tr:nth-child(odd) td{ background: #121b26; } /* zebra */
tr:hover td{ background:#0e141c; }
.controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin: 8px 0 12px 0; }
.kv{ display:flex; gap:6px; align-items:center; }
.bad{ color: var(--bad); }
.warn{ color: var(--warn); }
.ok{ color: var(--ok); }
.hidden{ display:none !important; }

.changedCell .oldVal{ color: var(--muted); }
.changedCell .arrow{ opacity:.8; padding:0 4px; }
.changedCell .newVal{ font-weight:600; }

/* PIE preview popup */
.pie-link{ cursor:pointer; color:var(--accent); }
#researchPopup{ position:fixed; top:50%; left:50%; max-width:80%; max-height:80%; padding:16px; transform:translate(-50%,-50%); background:#0a0f14; border:1px solid var(--border); border-radius:8px; z-index:100; overflow:auto; }
#researchPopup.hidden{ display:none; }
#researchPopup button{ position:absolute; top:4px; right:4px; background:none; border:none; color:var(--fg); cursor:pointer; }
.research-link{ cursor:pointer; color:var(--accent); }
#researchPopup ul{ list-style:none; margin:0; padding-left:1em; }
#researchPopup ul ul{ border-left:1px solid var(--border); margin-left:.6em; }
#researchPopup summary{ cursor:pointer; }
#piePopup{ position:fixed; top:50%; left:50%; width:400px; height:400px; margin:0; transform:translate(-50%,-50%); background:#0a0f14; border:1px solid var(--border); border-radius:8px; z-index:100; }
#piePopup.hidden{ display:none; }
#piePopup canvas{ width:100%; height:100%; display:block; }
#piePopup button{ position:absolute; top:4px; right:4px; background:none; border:none; color:var(--fg); cursor:pointer; }
</style>

</head>
<body>

<!-- Loader for PIE previews and Three.js helpers -->


<header>
  <h1>WZ Stats Viewer</h1>
  <span class="badge" id="sourceBadge">Source: local ./stats</span>
  <input type="file" id="uploadInput" style="display:none" />
  <label for="uploadInput" class="btn" id="uploadBtn">Upload</label>
  <button class="btn" id="loadDummyBtn">Load dumby test</button>
  <span class="small hidden" id="dummyStatus"></span>
  <span class="small" id="uploadHint" title="Windows: Documents\\Warzone 2100 4.5\\mods\\global | Linux: ~/.local/share/warzone2100-4.5/mods/global | macOS: ~/Library/Application Support/warzone2100-4.5/mods/global">Find MOD files in the game's mods/global folder</span>
</header>

<div class="container">
  <div class="panel">
    <div class="toolbar">
      <div class="tabbar">
        <div class="tab active" data-tab="structures">Structures</div>
        <div class="tab" data-tab="weapons">Weapons</div>
        <div class="tab" data-tab="research">Research</div>
      </div>
      <div class="controls">
        <input type="text" id="searchInput" placeholder="Search…" />
        <button class="secondary" id="clearBtn">Clear</button>
        <button class="secondary" id="filtersBtn">Show filters</button>
        <div class="tab" id="showNewBtn">Show new</div>
        <div class="tab" id="showChangedBtn">Show changes</div>
        <div class="kv small"><span>Rows:</span> <span id="rowCount">0</span></div>
        <div class="kv small"><span>Research chain:</span> <span id="researchChainTime"></span></div>
      </div>
    </div>

    <div id="filtersPanel" class="panel hidden" style="margin:8px 0;">
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <strong>Filters</strong>
        <button class="secondary" id="filtersSelectAll">All</button>
        <button class="secondary" id="filtersSelectDefault">Default</button>
        <button class="secondary" id="filtersChangedOnly">Only changed fields</button>
        <span class="small" id="filtersCounter"></span>
      </div>
      <div id="filtersList" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap:8px; margin-top:8px;"></div>
    </div>

    <div id="tableWrap" class="panel" style="padding:0; overflow:auto; max-height:80vh;">
      <table id="dataTable">
        <thead id="thead"></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<div id="piePopup" class="hidden">
  <button id="piePopupClose">&times;</button>
  <canvas width="400" height="400"></canvas>
</div>
<div id="researchPopup" class="hidden">
  <button id="researchPopupClose">&times;</button>
  <div id="researchPopupContent"></div>
</div>
<script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js";
  window.THREE = THREE;
  import "./js/pie.js";
  import "./js/piePreview.js";
  import "./js/piePreview-init.js";
  import "./js/pie-loader.js";
  const piePopup = document.getElementById('piePopup');
  const piePopupCanvas = piePopup.querySelector('canvas');
  const piePopupClose = document.getElementById('piePopupClose');
  piePopupClose.addEventListener('click', () => piePopup.classList.add('hidden'));
  const researchPopup = document.getElementById('researchPopup');
  const researchPopupContent = document.getElementById('researchPopupContent');
  const researchPopupClose = document.getElementById('researchPopupClose');
  if (researchPopupClose) researchPopupClose.addEventListener('click', () => researchPopup.classList.add('hidden'));
  const researchMap = new Map();
  async function showPiePopup(pieFile){
    piePopup.classList.remove('hidden');
    piePopup.setAttribute('aria-busy','true');
    try {
      let files = pieFile;
      if (typeof files === 'string') { try { files = JSON.parse(files); } catch(_) { files = [files]; } }
      if (!Array.isArray(files)) files = [files];
      await renderPieToCanvas(piePopupCanvas, files);
    } finally {
      piePopup.removeAttribute('aria-busy');
    }
  }
  function getResearchName(id){ const r = researchMap.get(String(id)); return r ? (r.name || r.id || String(id)) : String(id); }
  function formatTime(seconds){
    if (seconds === undefined || seconds === null || isNaN(seconds)) return '';
    seconds = Math.round(Number(seconds));
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    if (h > 0) return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
    return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
  }
  function calcTotalResearchTime(id, seen = new Set()){
    id = String(id);
    if (seen.has(id)) return { time12:0, time54:0 };
    seen.add(id);
    const node = researchMap.get(id);
    let t12 = (node && node.time12) || 0;
    let t54 = (node && node.time54) || 0;
    const prereqs = node && Array.isArray(node.requiredResearch)
      ? node.requiredResearch
      : (node && node.requiredResearch ? [node.requiredResearch] : []);
    prereqs.forEach(pr => {
      const t = calcTotalResearchTime(pr, seen);
      t12 += t.time12;
      t54 += t.time54;
    });
    return { time12:t12, time54:t54 };
  }
  function buildResearchTree(id, seen = new Set()){
    id = String(id);
    const li = document.createElement('li');
    const details = document.createElement('details');
    const node = researchMap.get(id);
    const summary = document.createElement('summary');
    const total = calcTotalResearchTime(id);
    if (total.time12 || total.time54) {
      const time = total.time54 || total.time12;
      summary.textContent = `${getResearchName(id)} (${formatTime(time)})`;
    } else {
      summary.textContent = getResearchName(id);
    }
    details.appendChild(summary);
    li.appendChild(details);
    if (seen.has(id)) return li;
    seen.add(id);
    const prereqs = node && Array.isArray(node.requiredResearch)
      ? node.requiredResearch
      : (node && node.requiredResearch ? [node.requiredResearch] : []);
    if (prereqs.length) {
      const ul = document.createElement('ul');
      prereqs.forEach(pr => ul.appendChild(buildResearchTree(pr, new Set(seen))));
      details.appendChild(ul);
    }
    return li;
  }
  function showResearchPopup(id){
    researchPopupContent.innerHTML = '';
    const tree = document.createElement('ul');
    tree.appendChild(buildResearchTree(id));
    researchPopupContent.appendChild(tree);
    // expand all nodes so the full research path is visible by default
    researchPopupContent.querySelectorAll('details').forEach(d => d.open = true);
    researchPopup.classList.remove('hidden');
  }
    const _pieBlobCache = {};
    async function resolvePieUrl(filename){
      if (Array.isArray(filename)) {
        const out = [];
        for (const f of filename) out.push(await resolvePieUrl(f));
        return out;
      }
      const orig = String(filename || '');
      if (orig.startsWith('__')) return orig;
      const lower = orig.toLowerCase();
      const isWeapon = /components\/weapons\//.test(lower);
      // PIE assets live directly under /pies; strip any path components.
      let name = lower.replace(/^.*[\\\/]/, '');
      const hashIdx = name.indexOf('#');
      const suffix = hashIdx >= 0 ? name.slice(hashIdx) : (isWeapon ? '#weapon' : '');
      const baseName = hashIdx >= 0 ? name.slice(0, hashIdx) : name;
      const store = (typeof window !== 'undefined' && window.BOOTSTRAP && window.BOOTSTRAP.pies) ? window.BOOTSTRAP.pies : null;
      if (store && store[baseName]) {
        if (!_pieBlobCache[baseName]) {
          _pieBlobCache[baseName] = URL.createObjectURL(new Blob([store[baseName]], { type: 'text/plain' }));
        }
        return _pieBlobCache[baseName] + suffix;
      }
      const baseUrl = `pies/${baseName}`;
      try {
        const res = await fetch(baseUrl, { method: 'HEAD' });
        if (res.ok) return baseUrl + suffix;
      } catch (_) {}
      // some stats reference PIE files with a leading zero that is
      // not present in the assets directory. Try stripping leading
      // zeroes and look for a matching file.
      const alt = baseName.replace(/^0+/, '');
      if (alt !== baseName) {
        const altBase = `pies/${alt}`;
        try {
          const res2 = await fetch(altBase, { method: 'HEAD' });
          if (res2.ok) return altBase + suffix;
        } catch (_) {}
      }
      return baseName + suffix;
    }
  async function renderPieToCanvas(canvas, pieFile){
    const files = Array.isArray(pieFile) ? pieFile : [pieFile];
    const url = await resolvePieUrl(files);
    try {
      await WZPIE.renderToCanvas(canvas, url, { background:'#0a0f14', zoom:0.5 });
      return true;
    } catch(e){ console.error('PIE render error:', e); }
    const ctx = canvas.getContext('2d');
    if (!ctx) return false;
    ctx.fillStyle = '#0a0f14';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const label = Array.isArray(files) ? String(files[0]) : String(files);
    ctx.fillStyle = '#9fc3ff';
    ctx.font = '11px system-ui, sans-serif';
    ctx.fillText(label.split('/').pop(), 6, 18);
    return false;
  }


(async function(){
  const UPLOAD_KEY = 'wzStatsUploadData';
  async function loadJSON(path){
    try{
      const res = await fetch(path);
      if(!res.ok) throw new Error("failed to load");
      return await res.json();
    }catch(e){
      console.error("Failed to load", path, e);
      return [];
    }
  }
  async function loadBootstrap(){
    const stored = localStorage.getItem(UPLOAD_KEY);
    if (stored){
      try {
        const parsed = JSON.parse(stored);
        if (!parsed.pies) parsed.pies = {};
        return parsed;
      }
      catch(e){ localStorage.removeItem(UPLOAD_KEY); }
    }
    const structures = await loadJSON("stats/structure.json");
    const weapons = await loadJSON("stats/weapons.json");
    const sensors = await loadJSON("stats/sensor.json");
    const research = await loadJSON("stats/research.json");
    return {
      meta:{source:"local", filename:null},
      base:"stats",
      structures,
      weapons,
      sensors,
      research,
      pies:{},
      files:{structures:"stats/structure.json", weapons:"stats/weapons.json", sensors:"stats/sensor.json", research:"stats/research.json"},
      baseline:{
        base:"stats",
        structures,
        weapons,
        sensors,
        research,
        files:{structures:"stats/structure.json", weapons:"stats/weapons.json", sensors:"stats/sensor.json", research:"stats/research.json"}
      }
    };
  }
  const BOOTSTRAP = await loadBootstrap();
  window.BOOTSTRAP = BOOTSTRAP;
  const sourceBadge = document.getElementById('sourceBadge');
  if (sourceBadge && BOOTSTRAP && BOOTSTRAP.meta){
    const name = BOOTSTRAP.meta.filename ? ` ${BOOTSTRAP.meta.filename}` : ' ./stats';
    sourceBadge.textContent = `Source: ${BOOTSTRAP.meta.source}${name}`;
  }
  const uploadBtn = document.getElementById('uploadBtn');
  const dummyBtn = document.getElementById('loadDummyBtn');
  const dummyStatus = document.getElementById('dummyStatus');
  if (BOOTSTRAP && BOOTSTRAP.meta){
    if (BOOTSTRAP.meta.source === 'upload' && uploadBtn){
      uploadBtn.textContent = 'Reset';
      uploadBtn.removeAttribute('for');
      uploadBtn.addEventListener('click', () => {
        localStorage.removeItem(UPLOAD_KEY);
        location.reload();
      });
    }
    if (BOOTSTRAP.meta.source === 'example'){
      if (uploadBtn) uploadBtn.classList.add('hidden');
      if (dummyBtn){
        dummyBtn.textContent = 'Unload';
        dummyBtn.addEventListener('click', () => {
          localStorage.removeItem(UPLOAD_KEY);
          location.reload();
        });
      }
      if (dummyStatus){
        dummyStatus.textContent = 'Loaded Dumby test';
        dummyStatus.classList.remove('hidden');
      }
    }
  }
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;'); }
  const isNumber = (v) => typeof v === 'number' || (typeof v === 'string' && v.trim() !== '' && !isNaN(Number(v)));
  const toCell = (v) => (v===null||v===undefined) ? '' : (typeof v === 'object' ? JSON.stringify(v) : String(v));
  const compareVals = (a, b) => { const an = isNumber(a), bn = isNumber(b); if (an && bn) return Number(a)-Number(b); a = String(a).toLowerCase(); b = String(b).toLowerCase(); return a<b?-1:a>b?1:0; };
  const PRETTY_LABELS = {
    buildpoints:'Build time',
    buildpower:'Price',
    damage:'DMG',
    hitpoints:'HP',
    longrange:'Range',
    weaponclass:'Type',
    time12:'Time (12/s)',
    time54:'Time (54/s)',
    researchpower:'Price',
    requiredresearch:'Requires'
  };
  const pretty = (k) => PRETTY_LABELS[k] || k;

  function isPlainObject(o){ return o && typeof o === 'object' && !Array.isArray(o); }
  function deepSort(v){ if (Array.isArray(v)) return v.map(deepSort); if (isPlainObject(v)) { const o={}; for (const k of Object.keys(v).sort()) o[k]=deepSort(v[k]); return o; } return v; }
  function stableStringify(v){ return JSON.stringify(deepSort(v)); }
  function toMap(rows){ const m=new Map(); (Array.isArray(rows)?rows:[]).forEach(r=>{ const id=(r && (r.id!==undefined && r.id!==null))?String(r.id):null; if(!id)return; const {id:_drop,...rest}=r; m.set(id,rest); }); return m; }
  function diffRows(activeRows, baselineRows){
    const A = toMap(activeRows), B = toMap(baselineRows); const out = [];
    for (const [id, aObj] of A.entries()){
      const bObj = B.get(id);
      if (bObj === undefined) out.push({ id, ...aObj, __delta:'new' });
      else {
        const sa = stableStringify(aObj), sb = stableStringify(bObj);
        if (sa !== sb) {
          const keys = new Set([...Object.keys(aObj), ...Object.keys(bObj)]);
          const changed = []; const oldmap = {};
          for (const k of keys){ const va=aObj[k], vb=bObj[k]; if (stableStringify(va) !== stableStringify(vb)) { changed.push(k); oldmap[k]=vb; } }
          out.push({ id, ...aObj, __delta:'changed', __changed:changed, __old:oldmap });
        }
      }
    }
    return out;
  }

  function unwrapByKind(data, kind){
    if (!data || typeof data !== 'object') return data;
    const candidates = kind === 'structures'
      ? ['structures','structure','STRUCTURES','STRUCTURE','StructureStats','structs']
      : kind === 'weapons'
        ? ['weapons','weampons','weapon','WEAPONS','WEAPON','WeaponStats','weaps']
        : kind === 'research'
          ? ['research','researches','RESEARCH','RESEARCHES','ResearchStats','topics']
          : ['sensors','sensor','SENSORS','SENSOR','SensorStats'];
    for (const k of candidates) if (Object.prototype.hasOwnProperty.call(data, k)) return data[k];
    return data;
  }
  function normalizeRows(data, kind){
    if (!data) return [];
    if (data && typeof data === 'object' && data.__error) return [];
    data = unwrapByKind(data, kind);
    if (Array.isArray(data)) return data.map((r,idx)=> (r && typeof r==='object' && !Array.isArray(r)) ? r : { id: idx, value: r });
    if (data && typeof data === 'object') return Object.entries(data).map(([k,v]) => (v && typeof v==='object' && !Array.isArray(v)) ? Object.assign({id:k}, v) : { id:k, value:v });
    return [];
  }

  let columnLookup = {};
  function unionKeys(rows){ if (!Array.isArray(rows)) return []; const set = new Set(); rows.forEach(r => { if (r && typeof r === 'object') Object.keys(r).forEach(k => set.add(k)); }); return Array.from(set); }
  function pickPrefer(keys, preferred){ const set = new Set(keys); const out = []; (preferred||[]).forEach(k => { if (set.has(k)) { out.push(k); set.delete(k); } }); return out.concat(Array.from(set).sort()); }

  function addResearchTime(rows){
    if (!Array.isArray(rows)) return;
    rows.forEach(r => {
      const pts = Number(r.researchPoints) || 0;
      r.time12 = pts / 12;
      r.time54 = pts / 54;
    });
  }

  const tabs = { structures: normalizeRows(BOOTSTRAP.structures, 'structures'), weapons: normalizeRows(BOOTSTRAP.weapons, 'weapons'), research: normalizeRows(BOOTSTRAP.research, 'research') };
  addResearchTime(tabs.research);
  const weaponMap = new Map();
  (tabs.weapons || []).forEach(w => { const id = (w && w.id !== undefined) ? String(w.id) : null; if (id) weaponMap.set(id, w); });
  const sensorMap = new Map();
  (normalizeRows(BOOTSTRAP.sensors, 'sensors') || []).forEach(s => { const id = (s && s.id !== undefined) ? String(s.id) : null; if (id) sensorMap.set(id, s); });
  (tabs.research || []).forEach(r => { const id = (r && r.id !== undefined) ? String(r.id) : null; if (id) researchMap.set(id, r); });
  const baseline = { structures: normalizeRows(BOOTSTRAP.baseline && BOOTSTRAP.baseline.structures, 'structures'), weapons: normalizeRows(BOOTSTRAP.baseline && BOOTSTRAP.baseline.weapons, 'weapons'), research: normalizeRows(BOOTSTRAP.baseline && BOOTSTRAP.baseline.research, 'research') };
  addResearchTime(baseline.research);

  function calcResearchChainTime(ids, baseSpeed, bonus){
    let total = 0;
    ids.forEach((id, idx) => {
      const r = researchMap.get(id);
      if (!r) return;
      const cost = Number(r.researchPoints) || 0;
      const speed = baseSpeed * (1 + bonus * idx);
      total += cost / speed;
    });
    return total;
  }

  const researchSpeedIds = [
    'R-Struc-Research-Upgrade01',
    'R-Struc-Research-Upgrade02',
    'R-Struc-Research-Upgrade03',
    'R-Struc-Research-Upgrade04',
    'R-Struc-Research-Upgrade05',
    'R-Struc-Research-Upgrade06',
    'R-Struc-Research-Upgrade07',
    'R-Struc-Research-Upgrade08',
    'R-Struc-Research-Upgrade09'
  ];

  const chainTime = calcResearchChainTime(researchSpeedIds, 21, 0.3);
  const chainEl = document.getElementById('researchChainTime');
  if (chainEl) chainEl.textContent = formatTime(chainTime);

  const baselineWeaponMap = new Map();
  (baseline.weapons || []).forEach(w => { const id = (w && w.id !== undefined) ? String(w.id) : null; if (id) baselineWeaponMap.set(id, w); });

  function augmentStructureTotals(rows, map){
    rows.forEach(r => {
      const basePoints = Number(r.buildPoints) || 0;
      const basePower = Number(r.buildPower) || 0;
      let weaponPoints = 0, weaponPower = 0;
      const ids = Array.isArray(r.weapons) ? r.weapons : (r.weapons !== undefined ? [r.weapons] : []);
      ids.forEach(id => {
        const w = map.get(String(id));
        if (w){
          weaponPoints += Number(w.buildPoints) || 0;
          weaponPower += Number(w.buildPower) || 0;
        }
      });
      r.weaponBuildPoints = weaponPoints;
      r.weaponBuildPower = weaponPower;
      r.totalBuildPoints = basePoints + weaponPoints;
      r.totalBuildPower = basePower + weaponPower;
    });
  }

  augmentStructureTotals(tabs.structures, weaponMap);
  augmentStructureTotals(baseline.structures, baselineWeaponMap);

  const diffs = { structures: diffRows(tabs.structures, baseline.structures), weapons: diffRows(tabs.weapons, baseline.weapons), research: diffRows(tabs.research, baseline.research) };

  const preferCols = {
    structures: ['id','name','type','buildPoints','weaponBuildPoints','totalBuildPoints','buildPower','weaponBuildPower','totalBuildPower','hitpoints','armour','thermal','strength','weapons','longrange','damage'],
    weapons: ['id','name','Damage','Range','ReloadTime','Class','model','baseModel'],
    research: ['id','name','time12','time54','researchPower','requiredResearch','resultComponents','results','statID']
  };

  let activeTab = 'structures';
  let showNew = false, showChanged = false;
  function diffMode(){ return !!(showNew || showChanged); }
  function getActiveRows(){
    if (diffMode()) {
      const base = diffs[activeTab] || [];
      return base.filter(r => ((showNew && r.__delta === 'new') || (showChanged && r.__delta === 'changed')));
    }
    return tabs[activeTab] || [];
  }

  let sortCol = null, sortDir = 1, visibleCols = [];
  const thead = document.getElementById('thead');
  const tbody = document.getElementById('tbody');
  const rowCount = document.getElementById('rowCount');
  const searchInput = document.getElementById('searchInput');
  const clearBtn = document.getElementById('clearBtn');
  const filtersBtn = document.getElementById('filtersBtn');
  const filtersPanel = document.getElementById('filtersPanel');
  const filtersList = document.getElementById('filtersList');
  const filtersSelectAll = document.getElementById('filtersSelectAll');
  const filtersSelectDefault = document.getElementById('filtersSelectDefault');
  const filtersChangedOnly = document.getElementById('filtersChangedOnly');
  const showNewBtn = document.getElementById('showNewBtn');
  const showChangedBtn = document.getElementById('showChangedBtn');

  tbody.addEventListener('click', (e) => {
    const target = e.target instanceof Element ? e.target : null;
    if (!target) return;
    const link = target.closest('.pie-link');
    if (link && link.dataset.pie) {
      showPiePopup(link.dataset.pie);
      return;
    }
    const rlink = target.closest('.research-link');
    if (rlink && rlink.dataset.id) {
      showResearchPopup(rlink.dataset.id);
    }
  });

  const STORAGE_KEY = 'wzStatsCols_v3';
  let columnSelections = {}; try { const saved = localStorage.getItem(STORAGE_KEY); if (saved) columnSelections = JSON.parse(saved) || {}; } catch(e){}
  function saveSelections(){ try { localStorage.setItem(STORAGE_KEY, JSON.stringify(columnSelections)); } catch(e){} }
  function selectionKey(){ return activeTab + (diffMode() ? ':diff' : ':all'); }

  function currentAllCols(){
    const rows = getActiveRows();
    const keys = unionKeys(rows);
    const prefer = [].concat(preferCols[activeTab] || []);
    let ordered = pickPrefer(keys, prefer);
    ordered = ordered.filter(k => { const kk = String(k).toLowerCase(); return kk !== '__delta' && kk !== '__changed' && kk !== '__old'; });
    columnLookup = {}; const out = [];
    for (const k of ordered){ const canon = String(k).toLowerCase(); if (!out.includes(canon)) { out.push(canon); columnLookup[canon] = [k]; } }
    return out;
  }

  const USER_DEFAULTS_KEY = 'wzStatsUserDefaultCols_v1'; let userDefaultCols = {}; try { const u = localStorage.getItem(USER_DEFAULTS_KEY); if (u) userDefaultCols = JSON.parse(u) || {}; } catch(e){}
  const defaultCols = { structures: ['name','type','buildpoints','weaponbuildpoints','totalbuildpoints','hitpoints','armour','thermal','strength','damage','longrange','buildpower','weaponbuildpower','totalbuildpower'], weapons: ['name','buildpoints','buildpower','damage','hitpoints','longrange','reloadtime','weaponclass'], research: ['name','time12','time54','researchpower','requiredresearch','results','resultcomponents','statid'] };
  function getDefaultCols(){ const all = currentAllCols(); const user = userDefaultCols[activeTab]; const wanted = (Array.isArray(user) && user.length ? user : (defaultCols[activeTab] || all)); return wanted.filter(c => all.includes(c)); }

  function getRaw(row, label){
    const list = (columnLookup[label] || [label]);
    for (const key of list){ if (row && row[key] !== undefined) return row[key]; }
    return row ? row[label] : undefined;
  }
  function getOldRaw(row, label){ if (!row || !row.__old) return undefined; const list = (columnLookup[label] || [label]); for (const key of list){ if (Object.prototype.hasOwnProperty.call(row.__old, key)) return row.__old[key]; } return row.__old[label]; }

  // Extract pie filenames for previews. Structures return their own models
  // and any linked weapon components or mounts. Weapon parts are left
  // untagged so they stack naturally with the base model.
  function extractPieNames(row){
    if (!row || typeof row !== 'object') return [];
    const out = [];
    const add = (s, prefix) => {
      if (!s) return;
      if (typeof prefix !== 'string') prefix = '';
      let name = String(s).trim().replace(/^\[|\]$/g,'');
      name = name.replace(/^\[\"']+|[\\"']+$/g,'');
      const parts = name.split(/[\\/]/);
      const last = parts[parts.length-1];
      const base = last.split('#')[0];
      if (/\.pie$/i.test(base)) {
        const full = prefix + last;
        if (!out.includes(full)) out.push(full);
      }
    };

    const weaponIds = row.weapons;
    const list = Array.isArray(weaponIds) ? weaponIds : (weaponIds !== undefined ? [weaponIds] : []);

    const handle = (v, prefix) => {
      if (Array.isArray(v)) v.forEach(s => add(s, prefix));
      else if (typeof v === 'string') {
        try {
          const arr = JSON.parse(v);
          if (Array.isArray(arr)) arr.forEach(s => add(s, prefix));
          else add(v, prefix);
        } catch (_) {
          add(v, prefix);
        }
      } else {
        add(v, prefix);
      }
    };

    const isWeaponRow = (activeTab === 'weapons') ||
                        (row.weaponClass !== undefined) ||
                        (row.weaponSubClass !== undefined) ||
                        (row.weaponEffect !== undefined) ||
                        (row.damage !== undefined);

    if (isWeaponRow) {
      // Use a neutral tower base so weapons preview the same way they mount on
      // structures. The mount model then stacks with the weapon so that both
      // parts are layered exactly as in game. Prefixing with
      // "components/weapons/" applies the same #weapon handling used for other
      // weapon components.
      handle('znullturret.pie', 'components/structures/');
      if (row.mountModel) handle(row.mountModel, 'components/weapons/');
      ['model','barrelModel','turretModel','modelFile','weaponsModel'].forEach(f => {
        if (row[f] !== undefined) handle(row[f], 'components/weapons/');
      });
      // Apply default rotation if weapon stats specify one. This mirrors
      // how structures rotate attached weapons.
      if (row.rotate !== undefined) out.push(`__rotate:${row.rotate}`);
    } else {
      const fields = ['baseModel','basemodel','structureModel','structuremodel','mountModel','model','barrelModel','turretModel','modelFile','weaponsModel'];
      for (const f of fields) {
        if (row[f] === undefined) continue;
        handle(row[f]);
      }
    }

    list.forEach(id => {
      if (id == null) return;
      const w = weaponMap.get(String(id));
      if (!w) return;
      if (w.mountModel) add(String(w.mountModel), 'components/weapons/');
      ['model','barrelModel','turretModel'].forEach(f => {
        if (w[f]) add(String(w[f]), 'components/weapons/');
      });
    });

    // include sensor models referenced by structures
    const sensorId = row.sensorID || row.sensorid;
    if (sensorId != null) {
      const s = sensorMap.get(String(sensorId));
      if (s) {
        ['mountModel','sensorModel'].forEach(f => {
          if (s[f]) add(String(s[f]) + '#stack');
        });
      }
    }
    return out;
  }

  function buildCols(){
    const allCols = currentAllCols();
    const key = selectionKey();
    let sel = columnSelections[key];
    if (!Array.isArray(sel) || !sel.length) sel = getDefaultCols();
    sel = sel.filter(c => allCols.includes(c));
    if (!sel.length) sel = getDefaultCols();
    visibleCols = sel;
  }

  function filterRows(rows, q){
    if (!Array.isArray(rows) || !q) return rows || [];
    const needle = q.toLowerCase();
    return rows.filter(r => {
      for (const c of visibleCols) { const v = toCell(getRaw(r,c)).toLowerCase(); if (v.includes(needle)) return true; }
      return false;
    });
  }

  function renderHeader(){
    thead.innerHTML = '';
    const tr = document.createElement('tr');
    visibleCols.forEach((col) => {
      const th = document.createElement('th');
      th.textContent = pretty(col);
      th.dataset.col = col;
      th.addEventListener('click', () => { if (sortCol === col) sortDir *= -1; else { sortCol = col; sortDir = 1; } renderBody(); });
      tr.appendChild(th);
    });
    thead.appendChild(tr);
  }

  function renderBody(){
    const all = getActiveRows();
    const q = searchInput.value.trim();
    let rows = filterRows(all, q);
    if (sortCol) rows = rows.slice().sort((a,b) => compareVals(getRaw(a,sortCol), getRaw(b,sortCol)) * sortDir);
    tbody.innerHTML = '';
    const frag = document.createDocumentFragment();
    rows.forEach(r => {
      const tr = document.createElement('tr');
      visibleCols.forEach(c => {
        const td = document.createElement('td');
        const valRaw = getRaw(r, c);
        const isTimeCol = c === 'time12' || c === 'time54';
        const isReqCol = c === 'requiredresearch';
        const val = isTimeCol ? formatTime(valRaw) : toCell(valRaw);
        const oldCandidate = getOldRaw(r, c);
        const isName = c === 'name';
        if (isName) {
          // Build name and attach PIE preview link (first PIE found)
          const pies = extractPieNames(r);
          const label = document.createElement('span');
          label.textContent = val;
          td.textContent = '';
          td.appendChild(label);
          if (activeTab === 'research') {
            label.classList.add('research-link');
            if (r.id !== undefined) label.dataset.id = r.id;
          }
          if (pies.length){
            label.classList.add('pie-link');
            try { label.dataset.pie = JSON.stringify(pies); } catch(_) { label.dataset.pie = pies[0]; }
          }
        } else if (isReqCol) {
          const ids = Array.isArray(valRaw) ? valRaw : (valRaw ? [valRaw] : []);
          td.textContent = '';
          ids.forEach((id, idx) => {
            if (idx) td.appendChild(document.createTextNode(', '));
            const span = document.createElement('span');
            span.textContent = getResearchName(id);
            span.classList.add('research-link');
            span.dataset.id = id;
            td.appendChild(span);
          });
          td.title = ids.join(', ');
        } else if (diffMode() && r.__delta === 'changed' && oldCandidate !== undefined) {
          const oldVal = isTimeCol ? formatTime(oldCandidate) : toCell(oldCandidate);
          td.classList.add('changedCell');
          td.innerHTML = '<span class="oldVal">' + escapeHtml(oldVal) + '</span>' +
                         '<span class="arrow">→</span>' +
                         '<span class="newVal">' + escapeHtml(val) + '</span>';
          td.title = oldVal + ' -> ' + val;
        } else {
          td.title = val;
          td.textContent = val;
        }
        tr.appendChild(td);
      });
      frag.appendChild(tr);
    });
    tbody.appendChild(frag);
    rowCount.textContent = String(rows.length);
  }

  function switchTab(name){
    activeTab = name;
    document.querySelectorAll('.tabbar .tab').forEach(el => el.classList.toggle('active', el.dataset.tab === name));
    buildCols(); renderHeader(); renderBody(); rebuildFiltersPanel();
  }

  function rebuildFiltersPanel(){
    if (!filtersPanel) return;
    const allCols = currentAllCols();
    const key = selectionKey();
    let sel = columnSelections[key]; if (!Array.isArray(sel) || !sel.length) sel = allCols.slice(0);
    filtersList.innerHTML = '';
    allCols.forEach(col => {
      const btn = document.createElement('button');
      btn.type = 'button'; btn.className = 'filter-chip'; btn.dataset.col = col;
      const selected = sel.includes(col);
      if (selected) btn.classList.add('active');
      btn.innerHTML = `<span class="label">${escapeHtml(pretty(col))}</span>`;
      btn.addEventListener('click', () => {
        const key = selectionKey();
        let cur = columnSelections[key]; if (!Array.isArray(cur)) cur = [];
        if (btn.classList.contains('active')) { cur = cur.filter(x => x !== col); btn.classList.remove('active'); }
        else { cur = cur.concat(col); btn.classList.add('active'); }
        columnSelections[key] = cur; saveSelections(); buildCols(); renderHeader(); renderBody(); rebuildFiltersPanel();
      });
      filtersList.appendChild(btn);
    });
    if (document.getElementById('filtersCounter')) {
      const selCount = (columnSelections[key] || allCols).length;
      document.getElementById('filtersCounter').textContent = `${selCount} / ${allCols.length} selected`;
    }
  }

  if (filtersBtn){
    filtersBtn.addEventListener('click', () => {
      filtersPanel.classList.toggle('hidden');
      const active = !filtersPanel.classList.contains('hidden');
      filtersBtn.classList.toggle('active', active);
      filtersBtn.textContent = active ? 'Hide filters' : 'Show filters';
      if (active) rebuildFiltersPanel();
    });
  }
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && filtersPanel && !filtersPanel.classList.contains('hidden')) {
      filtersPanel.classList.add('hidden');
      if (filtersBtn){
        filtersBtn.classList.remove('active');
        filtersBtn.textContent = 'Show filters';
      }
    }
  });
  filtersSelectAll && filtersSelectAll.addEventListener('click', () => { columnSelections[selectionKey()] = currentAllCols(); saveSelections(); buildCols(); renderHeader(); renderBody(); rebuildFiltersPanel(); });
  filtersSelectDefault && filtersSelectDefault.addEventListener('click', () => { columnSelections[selectionKey()] = getDefaultCols(); saveSelections(); buildCols(); renderHeader(); renderBody(); rebuildFiltersPanel(); });
  filtersChangedOnly && filtersChangedOnly.addEventListener('click', () => {
    const rows = diffs[activeTab] || []; const changed = new Set();
    rows.forEach(r => (r.__changed || []).forEach(k => changed.add(String(k).toLowerCase())));
    const base = ['id','name']; const all = currentAllCols();
    const list = base.concat(Array.from(changed)).filter(c => all.includes(c));
    columnSelections[selectionKey()] = list.length ? list : base.filter(c => all.includes(c));
    saveSelections(); buildCols(); renderHeader(); renderBody(); rebuildFiltersPanel();
  });

  function refreshToggles(){ showNewBtn && showNewBtn.classList.toggle('active', !!showNew); showChangedBtn && showChangedBtn.classList.toggle('active', !!showChanged); }
  showNewBtn && showNewBtn.addEventListener('click', () => { if (!showNew) { showNew=true; showChanged=false; } else { showNew=false; } refreshToggles(); buildCols(); renderHeader(); renderBody(); });
  showChangedBtn && showChangedBtn.addEventListener('click', () => { if (!showChanged) { showChanged=true; showNew=false; } else { showChanged=false; } refreshToggles(); buildCols(); renderHeader(); renderBody(); });

  if (BOOTSTRAP && BOOTSTRAP.meta && BOOTSTRAP.meta.source === 'upload' && (baseline.structures.length || baseline.weapons.length || baseline.research.length)) { showNew = true; showChanged = false; }
  refreshToggles();

  document.querySelectorAll('.tabbar .tab').forEach(el => el.addEventListener('click', () => switchTab(el.dataset.tab)));
  searchInput.addEventListener('input', renderBody);
  clearBtn.addEventListener('click', () => { searchInput.value=''; renderBody(); });

  async function extractZipText(buffer, filename){
    const dv = new DataView(buffer);
    let offset = 0;
    const sig = 0x04034b50;
    while (offset + 30 < dv.byteLength && dv.getUint32(offset, true) === sig){
      offset += 4;
      offset += 2; // version
      const flags = dv.getUint16(offset, true); offset += 2;
      const compression = dv.getUint16(offset, true); offset += 2;
      offset += 8; // times + crc32
      const compSize = dv.getUint32(offset, true); offset += 4;
      const uncompSize = dv.getUint32(offset, true); offset += 4;
      const nameLen = dv.getUint16(offset, true); offset += 2;
      const extraLen = dv.getUint16(offset, true); offset += 2;
      const name = new TextDecoder().decode(new Uint8Array(buffer, offset, nameLen));
      offset += nameLen + extraLen;
      const data = buffer.slice(offset, offset + compSize);
      offset += compSize;
      if (name === filename){
        if (compression === 0){
          return new TextDecoder().decode(data);
        } else if (compression === 8){
          const ds = new DecompressionStream('deflate-raw');
          const decompressed = await new Response(new Blob([data]).stream().pipeThrough(ds)).arrayBuffer();
          return new TextDecoder().decode(decompressed);
        } else {
          throw new Error('Unsupported compression method '+compression);
        }
      }
    }
    throw new Error('Missing '+filename+' in archive');
  }

  async function extractZipPies(buffer){
    const dv = new DataView(buffer);
    let offset = 0;
    const sig = 0x04034b50;
    const pies = {};
    while (offset + 30 < dv.byteLength && dv.getUint32(offset, true) === sig){
      offset += 4;
      offset += 2; // version
      const flags = dv.getUint16(offset, true); offset += 2;
      const compression = dv.getUint16(offset, true); offset += 2;
      offset += 8; // times + crc32
      const compSize = dv.getUint32(offset, true); offset += 4;
      const uncompSize = dv.getUint32(offset, true); offset += 4;
      const nameLen = dv.getUint16(offset, true); offset += 2;
      const extraLen = dv.getUint16(offset, true); offset += 2;
      const name = new TextDecoder().decode(new Uint8Array(buffer, offset, nameLen));
      offset += nameLen + extraLen;
      const data = buffer.slice(offset, offset + compSize);
      offset += compSize;
      if (/\.pie$/i.test(name)){
        let text = null;
        if (compression === 0){
          text = new TextDecoder().decode(data);
        } else if (compression === 8){
          const ds = new DecompressionStream('deflate-raw');
          const decompressed = await new Response(new Blob([data]).stream().pipeThrough(ds)).arrayBuffer();
          text = new TextDecoder().decode(decompressed);
        }
        if (text !== null){
          const base = name.split(/[/\\]/).pop().toLowerCase();
          if (!pies[base]) pies[base] = text;
        }
      }
    }
    return pies;
  }

  async function parseUploadedFile(f){
    const buf = await f.arrayBuffer();
    try {
      let text = new TextDecoder().decode(buf);
      if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
      const obj = JSON.parse(text);
      if (!obj.pies) obj.pies = {};
      return obj;
    } catch (e) {
      try {
        const structText = await extractZipText(buf, 'stats/structure.json').catch(()=>extractZipText(buf,'stats/structures.json'));
        const weaponText = await extractZipText(buf, 'stats/weapons.json');
        const sensorText = await extractZipText(buf, 'stats/sensor.json').catch(()=> '[]');
        const researchText = await extractZipText(buf, 'stats/research.json').catch(()=> '[]');
        const pies = await extractZipPies(buf).catch(()=> ({}));
        const structuresData = JSON.parse(structText);
        const weaponsData = JSON.parse(weaponText);
        const sensorsData = JSON.parse(sensorText);
        const researchData = JSON.parse(researchText);
        const structures = Array.isArray(structuresData) ? structuresData : (structuresData.structures ? structuresData.structures : Object.values(structuresData));
        const weapons = Array.isArray(weaponsData) ? weaponsData : (weaponsData.weapons ? weaponsData.weapons : Object.values(weaponsData));
        const sensors = Array.isArray(sensorsData) ? sensorsData : (sensorsData.sensors ? sensorsData.sensors : Object.values(sensorsData));
        const research = Array.isArray(researchData) ? researchData : (researchData.research ? researchData.research : Object.values(researchData));
        return { structures, weapons, sensors, research, pies };
      } catch (zipErr) {
        throw new Error('Unsupported file type');
      }
    }
  }

  async function saveData(data, source, filename){
    let baseStructs = await loadJSON('stats/structure.json');
    let baseWeapons = await loadJSON('stats/weapons.json');
    let baseSensors = await loadJSON('stats/sensor.json');
    let baseResearch = await loadJSON('stats/research.json');
    if (!baseStructs.length && BOOTSTRAP && BOOTSTRAP.baseline && Array.isArray(BOOTSTRAP.baseline.structures)) {
      baseStructs = BOOTSTRAP.baseline.structures;
    }
    if (!baseWeapons.length && BOOTSTRAP && BOOTSTRAP.baseline && Array.isArray(BOOTSTRAP.baseline.weapons)) {
      baseWeapons = BOOTSTRAP.baseline.weapons;
    }
    if (!baseSensors.length && BOOTSTRAP && BOOTSTRAP.baseline && Array.isArray(BOOTSTRAP.baseline.sensors)) {
      baseSensors = BOOTSTRAP.baseline.sensors;
    }
    if (!baseResearch.length && BOOTSTRAP && BOOTSTRAP.baseline && Array.isArray(BOOTSTRAP.baseline.research)) {
      baseResearch = BOOTSTRAP.baseline.research;
    }
    const store = {
      meta:{source, filename},
      base:source,
      structures:data.structures || [],
      weapons:data.weapons || [],
      sensors:data.sensors || [],
      research:data.research || [],
      pies:data.pies || {},
      files:{},
      baseline:{ base:'stats', structures:baseStructs, weapons:baseWeapons, sensors:baseSensors, research:baseResearch, files:{structures:'stats/structure.json', weapons:'stats/weapons.json', sensors:'stats/sensor.json', research:'stats/research.json'} }
    };
    localStorage.setItem(UPLOAD_KEY, JSON.stringify(store));
    location.reload();
  }

  const uploadInput = document.getElementById('uploadInput');
  if (uploadInput){
    uploadInput.addEventListener('change', async () => {
      const f = uploadInput.files && uploadInput.files[0];
      if (!f) return;
      try{
        const data = await parseUploadedFile(f);
        await saveData(data, 'upload', f.name);
      }catch(e){
        alert('Failed to load file: ' + e.message);
      }
    });
  }

  if (dummyBtn && (!BOOTSTRAP || !BOOTSTRAP.meta || BOOTSTRAP.meta.source !== 'example')){
    dummyBtn.addEventListener('click', async () => {
      try{
        const res = await fetch('example');
        if (!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        const file = new File([blob], 'example');
        const data = await parseUploadedFile(file);
        await saveData(data, 'example', 'example');
      }catch(e){
        alert('Failed to load file: ' + e.message);
      }
    });
  }

  switchTab('structures');
})();
</script>


</body>
</html>

